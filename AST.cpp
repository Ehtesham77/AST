#include<iostream>
#include<string>
#include<vector>
using namespace std;

/*AST classes*/
class ExprAST {
};
class AssignmentExpAST :public ExprAST {
	string var; //variable to be assigned a value
	int value; //value to be assigned
public:
	AssignmentExpAST(string var, int value) : var(var), value(value) {}
};
class BinaryExprAST :public ExprAST {
	char OP;
	ExprAST* left;
	ExprAST* right;
public:
	BinaryExprAST(char OP, ExprAST* left, ExprAST* right) :OP(OP), left(left), right(right) {}
};
/*these nodes are terminals so no children*/
class NumberExpNode :public ExprAST {
	int num;
public:
	NumberExpNode(int num) :num(num) {}
};
class IdentifierExpNode :public ExprAST {
	string identifier;
public:
	IdentifierExpNode(string identifier) :identifier(identifier) {}
};

/*to define token generated from lexical analyzer*/
struct token
{
	string lexeme; //lexeme is the actual value
	string type; // to identify types
	token(string lexeme, string type) :lexeme(lexeme), type(type) {}//default constructor
};
/*this function returns a vector of token after lexical analysis*/
vector<token> LexicalAnalysis(string source_code)
{
	/*To make lexical analysis simple everything is just one character long*/
	vector<token> tokens;
	for (int i = 0; i < source_code.size(); i++)
	{
		if (source_code[i] == ' ' || source_code[i] == '\n')/*skip whitespaces*/
			continue;
		else if (source_code[i] == '=')
			tokens.push_back(token("", "ASSIGN"));
		else if (source_code[i] == '(')
			tokens.push_back(token("", "LBRACE"));
		else if (source_code[i] == ')')
			tokens.push_back(token("", "RBRACE"));
		else if (source_code[i] == '+')
			tokens.push_back(token("", "PLUS"));
		else if (source_code[i] == '-')
			tokens.push_back(token("", "MINUS"));
		else if (source_code[i] == '*')
			tokens.push_back(token("", "MUL"));
		else if (source_code[i] == '/')
			tokens.push_back(token("", "DIV"));
		else if (isalpha(source_code[i]))
			tokens.push_back(token(to_string(source_code[i]), "ID"));
		else if (!isalpha(source_code[i]))
			tokens.push_back(token(to_string(source_code[i]), "INTEGERVAL"));
		else
		{
			cout << "bad token" << endl;
			exit(0);
		}
	}
	tokens.push_back(token("", "EOF"));
	return tokens;
}
/*Parsing starts from here*/
/*The backbone of a compiler this generates AST*/
/*function forward declaration*/
bool statement();
ExprAST* expression();
ExprAST* assignment();
ExprAST* factor();
ExprAST* term();
ExprAST* term_dash(ExprAST*);
ExprAST* exp_dash(ExprAST*);
vector<token> tokens;//to hold tokens generated by Lexiacl Analyzer
int i = 0;//index to keep track of next token
token getNextToken()
{
	return tokens[i++];
}
token getToken()
{
	return tokens[i];
}
token expect(string type)
{
	token t = getNextToken();
	if (t.type != type)
	{
		cout << "syntax error" << endl;
		exit(0);
	}
	return t;
}
//start->statement start
//start ->^
void start()
{
	if (statement())
	{
		start();
	}
}
//statement->assignment
//statement->expression
bool statement()
{
	if (assignment())
		return true;
	else if (expression())
		return true;
	return false;
}
//assignment -> IDENTIFIER ASSIGN INTEGERVAL {assignment.s = new AssignmentExpAST(IDENTIFIER.lexeme, atoi(INTEGERVAL.lexeme));}
ExprAST* assignment()
{
	if (getToken().type == "ID")
	{
		token t1 = expect("ID");
		expect("ASSIGN");
		token t2 = expect("INTEGERVAL");
		return new AssignmentExpAST(t1.lexeme, atoi(t2.lexeme.c_str()));
	}
	return NULL;
}
//expression->term{ exp_dash.i = term.s; }
//exp_dash{ expression.s = exp_dash.s; }
ExprAST* expression()
{
	ExprAST* left = term();
	if (left)
	{
		return exp_dash(left);
	}
	return NULL;
}
//exp_dash -> + term{ exp_dash.i = new BinaryExprAST("+", term.s, exp_dash.i); }
//				      exp_dash{ exp_dash.s = exp_dash.s; }
//exp_dash -> - term{ exp_dash.i = new BinaryExprAST("-", term.s, exp_dash.i); }
//				      exp_dash{ exp_dash.s = exp_dash.s; }
//exp_dash ->^ {exp_dash.s = exp_dash.i; }
ExprAST* exp_dash(ExprAST* exp)
{
	if (getToken().type == "PLUS")
	{
		expect("PLUS");
		ExprAST* val = term();
		return exp_dash(new BinaryExprAST('+', exp, val));
	}
	else if (getToken().type == "MINUS")
	{
		expect("MINUS");
		ExprAST* val = term();
		return exp_dash(new BinaryExprAST('-', exp, val));
	}
	else
	{
		return exp;
	}
}
//term->factor{ term_dash.i = factor.s; }
//		term_dash{ term_dash.s = term_dash.s; }
ExprAST* term()
{
	ExprAST* exp = factor();
	return term_dash(exp);
}
//term_dash ->* factor{ term_dash.i = new BinaryExprAST("*", factor.s, term_dash.i); }
//				      term_dash{ term_dash.s = term_dash.s; }
//term_dash ->/ factor{ term_dash.i = new BinaryExprAST("/", factor.s, term_dash.i); }
//			        term_dash{ term_dash.s = term_dash.s; }
//term_dash ->^ {term_dash.s = term_dash.i; }
ExprAST* term_dash(ExprAST* exp)
{
	if (getToken().type == "MUL")
	{
		expect("MUL");
		ExprAST* val = factor();
		return exp_dash(new BinaryExprAST('*', exp, val));
	}
	else if (getToken().type == "DIV")
	{
		expect("DIV");
		ExprAST* val = factor();
		return exp_dash(new BinaryExprAST('/', exp, val));
	}
	else
	{
		return exp;
	}
}

//factor -> INTEGERVAL   {factor.s = new NumberExpNode(atoi(INTEGERVAL.lexeme)); }
//factor -> IDENTIFIER   {factor.s = new IdentifierExpNode(IDENTIFIER.lexeme); }
//factor -> (expression) {factor.s = expression.s; }
ExprAST* factor()
{
	if (getToken().type == "INTEGERVAL")
	{
		token t1 = expect("INTEGERVAL");
		return new NumberExpNode(atoi(t1.lexeme.c_str()));
	}
	else if (getToken().type == "ID")
	{
		token t1 = expect("ID");
		return  new IdentifierExpNode(t1.lexeme);
	}
	else if (getToken().type == "LBRACE")
	{
		expect("LBRACE");
		ExprAST* exp = expression();
		expect("RBRACE");
		return exp;
	}
	return NULL;
}
int main()
{
	string source_code = "x = 1\ny = 2 3*(x+y)";
	/*The source code is a string
	You can also read your entire source file in a string first
	It all depends on you*/
	tokens = LexicalAnalysis(source_code);
	start();
	expect("EOF");//dummy token that was pushed at the end of lexical analysis to identify EndOFFile
	return 0;
}
